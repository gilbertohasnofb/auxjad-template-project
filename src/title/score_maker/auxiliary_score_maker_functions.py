import os
import shutil
from collections import namedtuple
from typing import Optional, Tuple, List

import abjad
import auxjad
from tqdm import tqdm

from .. import segments
from .. import tools


def create_staves(
        *,
        composition_filename: str
    ) -> Tuple[List[abjad.Staff], List[namedtuple]]:
    r"""
    Creates list of staves and list of instrument properties (staves, instrument names, clefs,
        etc.).

    Arguments:
        composition_filename: str with the filename of the composition

    Returns
        Tuple containing list of abjad.Staff's and list of namedtuple's
    """
    print()
    print(composition_filename)
    print('=================')
    print()

    # creating staves
    staff_1 = abjad.Staff(name='Flute')
    staff_2 = abjad.Staff(name='Piano_Upper')
    staff_3 = abjad.Staff(name='Piano_Lower')
    staff_4 = abjad.Staff(name='Harp_Upper')
    staff_5 = abjad.Staff(name='Harp_Lower')
    staff_6 = abjad.Staff(name='Cello')
    staves = [staff_1,
              staff_2,
              staff_3,
              staff_4,
              staff_5,
              staff_6,
              ]

    # creating staff groups
    staff_group_1 = abjad.StaffGroup([staff_2, staff_3],
                                     name='Piano',
                                     lilypond_type='PianoStaff',
                                     )
    staff_group_2 = abjad.StaffGroup([staff_4, staff_5],
                                     name='Harp',
                                     lilypond_type='GrandStaff',
                                     )
    
    # creating instrument properties (can be extended to include initial dynamics, pedalling, etc.)
    InstrumentProperties = namedtuple(
        'Staff', 
        [
            'container',
            'instrument_name',
            'short_instrument_name',
            'initial_clef',
            'context',
        ]
    )
    instrument_properties = [
        InstrumentProperties(
            container=staff_1,
            instrument_name='Flute',
            short_instrument_name='Fl.',
            initial_clef='treble',
            context='Staff',
        ),
        InstrumentProperties(
            container=staff_group_1,
            instrument_name='Piano',
            short_instrument_name='Pno.',
            initial_clef=['treble', 'bass'],
            context='PianoStaff',
        ),
        InstrumentProperties(
            container=staff_group_2,
            instrument_name='Harp',
            short_instrument_name='Hp.',
            initial_clef=['treble', 'bass'],
            context='GrandStaff',
            ),
        InstrumentProperties(
            container=staff_6,
            instrument_name='Cello',
            short_instrument_name='Vcl.',
            initial_clef='bass',
            context='Staff',
        ),
    ]

    return staves, instrument_properties


def generate_and_add_segments_to_staves(staves: List[abjad.Staff]) -> None:
    r"""
    Generates musical materials from segments and adds them to the staves.

    Arguments:
        staves: list of abjad.Staff's

    Returns
        None
    """
    print('Generating musical segments')
    print('---------------------------')
    print()

    list_of_segments = []
    for i, segment in enumerate(segments.segment_factory()):
        list_of_segments.append(segment)

    print('Adding segments to staves')
    print('-------------------------')
    print()

    with tqdm(total=len(list_of_segments) * len(staves)) as pbar:
        for segment in list_of_segments:
            for staff, music in zip(staves, segment):
                staff.extend(music)
                pbar.update(1)
    print()


def prettify_score(staves: List[abjad.Staff]) -> None:
    r"""
    Prettifies score (e.g. remove repeated time signatures, repeated dynamics, etc.)

    Arguments:
        staves: list of abjad.Staff's

    Returns
        None
    """
    # prettifying score
    print('Prettifying score')
    print('-----------------')
    print()

    with tqdm(total=len(staves)) as pbar:
        for staff in staves:
            auxjad.mutate.remove_repeated_time_signatures(staff[:])
            auxjad.mutate.remove_repeated_dynamics(staff[:])
            pbar.update(1)
    print()

    # manual fixes
    # print('Manual fixes')
    # print('------------')
    # print()
    #
    # <... code ...>
    # print()


def generate_lilypond_file_structure(
        instrument_properties: List[namedtuple],
    ) -> Tuple[abjad.LilyPondFile, abjad.Score]:
    r"""
    Creates the structure of the LilyPond file

    Arguments:
        instrument_properties: list of namedtuples with instrument properties containing the field
            name container for all staves and staff groups, generated by create_staves()

    Returns
        Tuple containing an abjad.LilyPondFile and an abjad.Score
    """
    # creating .ly file structure
    print('Generating LilyPond file structure')
    print('----------------------------------')
    print()

    # creating score and appending instruments
    score = abjad.Score()
    for instrument in instrument_properties:
        score.append(instrument.container)
    
    # creating blocks and including stylesheet
    score_block = abjad.Block(name='score')
    layout_block = abjad.Block(name='layout')
    midi_block = abjad.Block(name='midi')
    midi_block.items.append(r'\tempo 4 = 60')  # WARNING: must change tempo in stylesheet too!
    score_block.items.append(score)
    score_block.items.append(layout_block)
    score_block.items.append(midi_block)
    lilypond_file = abjad.LilyPondFile(
        items=[score_block],
        includes=['./includes/stylesheet.ily'],
    )

    return lilypond_file, score


def add_large_time_signatures(
        staves: List[abjad.Staff],
        score: abjad.Score,
    ) -> None:
    r"""
    Optional function that adds large time signatures above the first staff of the score and removes
        time signatures from all staves.

    Arguments:
        staves: list of abjad.Staff's
        score: abjad.Score created by generate_lilypond_file_structure()

    Returns
        None
    """
    # creating time-signature-only staff for large time signatures
    time_sig_staff = abjad.Staff(lilypond_type='TimeSig')
    time_signatures = auxjad.get.time_signature_list(
        staves[0],
        do_not_use_none=True,
    )
    previous_time_signature = None
    for time_signature in time_signatures:
        rests = abjad.LeafMaker()([None], time_signature.duration)
        if time_signature != previous_time_signature:
            abjad.attach(time_signature, abjad.select(rests).leaf(0))
        time_sig_staff.append(rests)
        previous_time_signature = time_signature
    numeric_timesignature = abjad.LilyPondLiteral(r'\numericTimeSignature')
    abjad.attach(numeric_timesignature, abjad.select(time_sig_staff).leaf(0))
    score.insert(0, time_sig_staff)


def add_instrument_names(instrument_properties: List[namedtuple]) -> None:
    r"""
    Adds full and short instrument names to all staves and staff groups.

    Arguments:
        instrument_properties: list of namedtuples with instrument properties containing the field
            names container, instrument_name, short_instrument_name, and context for all staves and
            staff groups, generated by create_staves()

    Returns
        None
    """
    for instrument in instrument_properties:
        # for better spacing, adding whitespace to end of instrument names
        instrument_name = instrument.instrument_name
        if instrument_name[-1] != ' ':
            instrument_name + ' '
        short_instrument_name = instrument.short_instrument_name
        if short_instrument_name[-1] != ' ':
            short_instrument_name + ' '
        
        # creating markups
        instrument_name_markup = abjad.StartMarkup(
            context=instrument.context,
            markup=abjad.Markup(instrument_name),
        )
        short_instrument_name_markup = abjad.MarginMarkup(
            context=instrument.context,
            markup=abjad.Markup(short_instrument_name),
        )

        # attaching markups
        abjad.attach(instrument_name_markup,
                     abjad.select(instrument.container).leaf(0),
                     )
        abjad.attach(short_instrument_name_markup,
                     abjad.select(instrument.container).leaf(0),
                     )
        

def add_initial_clefs(instrument_properties: List[namedtuple]) -> None:
    r"""
    Adds initial clefs to all

    Arguments:
        instrument_properties: list of namedtuples with instrument properties containing the field
            names container and initial_clef for all staves and staff groups, generated by
            create_staves(). initial_clef must be a str for single staves, and list of str for staff
            groups

    Returns
        None
    """
    # adding initial clefs
    for instrument in instrument_properties:
        if instrument.initial_clef is None:
            continue
        elif isinstance(instrument.initial_clef, list):
            for staff, clef in zip(instrument.container, instrument.initial_clef):
                abjad.attach(abjad.Clef(clef),
                            abjad.select(staff).leaf(0),
                            )
        else:
            abjad.attach(abjad.Clef(instrument.initial_clef),
                        abjad.select(instrument.container).leaf(0),
                        )
            
def add_tempo_and_final_tweaks(
        staves: List[abjad.Staff],
        score: abjad.Score,
    ) -> None:
    r"""
    Adds tempo marking, final bar line, and other final tweaks to the staves.

    Arguments:
        staves: list of abjad.Staff's
        score: abjad.Score created by generate_lilypond_file_structure()

    Returns
        None
    """
    # tempo markup (defined as a LilyPond variable in stylesheet)
    tempo_markup = abjad.LilyPondLiteral(r'\tempo-markup')
    for staff in staves:
        abjad.attach(tempo_markup, abjad.select(staff).leaf(0))

    # adding pedal marks and initial dynamics
    # <... code ...>

    # adding final bar
    score.add_final_bar_line()


def compile_ly_file(
        lilypond_file: abjad.LilyPondFile,
        *,
        composition_filename: str,
        composition_root_directory: str,
    ) -> None:
    r"""
    Creates list of staves and list of instrument properties (staves, instrument names, clefs,
        etc.).

    Arguments:
        lilypond_file: abjad.LilyPondFile created by generate_lilypond_file_structure()
        composition_filename: str with the filename of the composition
        root_directory: str with the composition root directory 

    Returns
        None
    """
    print('Compiling .ly file')
    print('------------------')
    print()
    # creating build directory

    if os.path.exists(f'{composition_root_directory}/build'):
        print(f'Directory {composition_root_directory}/build already exists, removing it')
        shutil.rmtree(f'{composition_root_directory}/build')
    print(f'Creating directory {composition_root_directory}/build')
    os.mkdir(f'{composition_root_directory}/build')
    print()

    # copying .ily files to build directory
    try:
        os.mkdir(f'{composition_root_directory}/build/includes')
    except:
        print(f'Directory {composition_root_directory}/build/includes already exists')
        print()
    finally:
        shutil.copyfile(f'{composition_root_directory}/includes/stylesheet.ily',
                        f'{composition_root_directory}/build/includes/stylesheet.ily',
                        )
    
    # generating files
    abjad.persist.as_pdf(
        lilypond_file,
        f'{composition_root_directory}/build/{composition_filename}.pdf',
    )

    # confirm build successful
    if os.path.exists(f'{composition_root_directory}/build/{composition_filename}.pdf'):
        print('Success')
    else:
        print('Something went wrong, build was not successful')
    print()
